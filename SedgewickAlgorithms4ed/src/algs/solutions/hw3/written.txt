HOMEWORK 3:  George Heineman (Solution)


Question 1 : Stack Exercise

One way to solve this is to go ahead and try to come up with a sequence of push and pop
operations. Note that the digits all have to be in order.

a. 4 3 2 1 0 9 8 7 6 5 

	0 1 2 3 4 - - - - - 5 6 7 8 9 - - - - -

b. 4 6 8 7 5 3 2 9 0 1

Look for out of sequence digits. If the final digit of the output is a 1, you can ask
yourself what happened to the zero? It must have already been popped off; but for this
to happen, there there is no way that the 4 was the first digit to appear on the output. 
Think about it this way, for the 4 to be the first value output, then "0 1 2 3" must all
have been pushed onto the stack, and still remain there; thus 0 must appear after 1.

c. 2 5 6 7 4 8 9 3 1 0

 	0 1 2 - 3 4 5 - 6 - 7 - - 8 - 9 - - - -

d. 4 3 2 1 0 5 6 7 8 9

	0 1 2 3 4 - - - - - 5 - 6 - 7 - 8 - 9 -

e. 1 2 3 4 5 6 9 8 7 0
 
	0 1 - 2 - 3 - 4 - 5 - 6 - 7 8 9 - - - -

f. 0 4 6 5 3 8 1 7 2 9 

Since 0 and 4 are the first two values popped off (in that order) then just before
popping the 4, the stack contains (in this order): "1 2 3" where 3 is on the top
of the stack and the next to be popped. Which means that 2 must popped off of the 
stack before 1. However, in the above output, 1 appears before 2, so this is impossible.

g. 1 4 7 9 8 6 5 3 0 2

This has an ALMOST valid sequence. Since "1 4" are popped in order, this means that "0 2 3"
are on the stack in this order. However, in the output representation, the 0 comes before
the 2, which is impossible given this stack.

h. 2 1 4 3 6 5 8 7 9 0 

	0 1 2 - - 3 4 - - 5 6 - - 7 8 - - 9 - - 
	
Question 2 : Data Type Exercise

See code for implementation.

Question 3: Algorithm Design

(b) Since this is essentially a modified binary search, and you only make a single array 
inspection with each pass through the while loop, the number of array inspections is
1 + Floor(log n) where n is the number of elements in the list. See sample code that
empirically computes this.

Note: What if you used Ceiling? Well, if (log n) is exactly equal to an integer (which happens
when n is a power of 2), then floor(log n) is equal to ceiling(log n) otherwise 
1+floor(log n) = Ceiling(log n). So to be precise, I always stay with 1+floor(log n).

You can hand-compute on a small answer to be sure you have the right value.

Question 4: Analyzing runtime performance.

                                              frequency      cost
public static int count(Integer[] a) {
  int N = a.length;                             _1_           _t0_
  Quick.sort(a);                                _1_           _t1 * (N log N)
  int cnt = 0;                                  _1_           _t2_
  
  for (int i = 0; i < N; i++) {                 BLOCK[
    for (int j = i+1; j < N; j++) {             
      int k = rank (a, -(a[i] + a[j]));         _N^2/2-N/2_   _t3*(1 + floor(log N))_
      if (k > j) cnt++;                         _N^2/2-N/2_   _t4_
    }
  }                                             ]
  
  return cnt;                                   _1_           _t5_
}

The challenge with dealing with the two for loops is that you can begin to account for the costs
of the innermost block of statements once you realize that i goes from 0 to (N-1) while j goes
from i+1 to (N-1). This was covered on p. 181 and in class as an example to show that the total
number of times the innermost statement block executes is (N-1)(N-2)/2 which is N^2/2 - N/2.

For the cost column, perhaps you could have used just 1 for all ones, except for t1*N Log N and 
t3*(1 + floor(log N)).

Now you have to sum everything up by multiplying frequency*cost

t0*1 + t1*N log N + t2*1 + t3*(N^2/2-N/2)*(1 + floor(log N)) +  t4*(N^2/2-N/2) + t5

which becomes (t0+t2+t5) + t1*N log N + (t3+t4)*(N^2/2 - N/2) + t3*(N^2/2 - N/2)*floor(log N)

*** in tilde, you can eliminate floors and ceilings:

= (t0+t2+t5) + t1*N log N + (t3+t4)*(N^2/2) - (t3+t4)*(N/2) + t3*(N^2/2)*log N - t3*(N/2)*log N

NOW, at this point, look at highest order terms.

The highest order term here is the t3*(N^2/2)*log N, which will outpace all the rest.

Thus the tilde equation becomes ~ t3*N^2/2 * log N.
 
NOTE: If students only used 1 for all of these instead of (t0,t2,t4,t5) that would be ok. They
still need to have (t1 and t3) however because those reveal the time is directly proportionate to
the equations. Using 1 is a simplification.